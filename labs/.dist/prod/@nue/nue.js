function h(Y){const{root:Q,fn:R,fns:T,deps:j,ctx:N}=Y;var B,K,U,F,g,I,Z=[];function C(H){return new Proxy({},{get(E,X){if(I){const S=F.indexOf(X);if(S>=0)return H[S]}return X===F?H:F.includes(X)?H[X]:X==g?U.indexOf(H):N[X]}})}function V(H,E,X,S){const J=_({fns:T,dom:Q.cloneNode(!0)},C(H),j,N);Z[S?"unshift":"push"](J),J.before(S||B),N.oninsert?.call(N,J.$el,H,{index:E,is_repaint:!!X,is_first:!E,is_last:E==U.length-1,items:U})}function O(){Z.forEach((H)=>H.unmount()),Z=[],U.forEach(V)}function A(H){const{unshift:E,splice:X,push:S,sort:J,reverse:q}=H;return Object.assign(H,{push(z){S.call(U,z),V(z,U.length-1)},unshift(z){E.call(U,z),V(z,0,null,Z[0].$el)},sort(z){J.call(U,z),O()},reverse(){q.call(U),O()},splice(z,D){Z.slice(z,z+D).forEach((G)=>G.unmount()),Z.splice(z,D),X.call(U,z,D)},shift(){H.splice(0,1)},pop(){H.splice(H.length-1,1)},remove(z){const D=U.indexOf(z);if(D>=0)H.splice(D,1)}})}function w(){var H;if([F,H=[],g,I]=R(N),U){if(H!==K)U=A(H),O(),K=H;return Z.forEach((E)=>E.update())}if(H){const E=Q.parentElement;B=new Text(""),E.insertBefore(B,Q),E.removeChild(Q),U=A(H),H.forEach(V),K=H}}return{update:w}}function $(Y){const{root:Q,fn:R,fns:T,deps:j,ctx:N}=Y,B=[];var K=Q,U,F;function g(Z,C){Y.processAttrs(Z);const V=_({fns:T,dom:Z},N,j,N);B.push(V),V.fn=C}g(Q,R);while(K=K.nextElementSibling){const Z=K.getAttribute(":else-if");if(Z)g(K,T[Z]),K.removeAttribute(":else-if");else if(K.hasAttribute(":else"))g(K,()=>!0),K.removeAttribute(":else");else{F=K;break}}function I(){if(!U){const C=Q.parentElement;U=new Text(""),C.insertBefore(U,Q)}const Z=B.find((C)=>C.fn(N));B.forEach((C)=>C==Z?C.before(U):C.unmount())}return{update:I,next:F}}var f=function(Y){const Q=document.createElement("_");return Q.innerHTML=Y.trim(),Q.firstChild},u=function(Y,Q=""){return Y?.join?Y.filter((R)=>R||R===0).join(Q).trim().replace(/\s+/g," "):Y||""},y=function(Y,Q){if(Y==Q)return[Y];if(!Y.join)Y=[Y];if(Q&&!Q.join)Q=[Q];return Y.concat(Q)},b={":if":$,":for":h},x=["class","style","id"];function _(Y,Q={},R=[],T={}){const{Impl:j,tmpl:N,fns:B=[],dom:K,inner:U}=Y,F=[];function g(q){const z=q.nodeType;if(z==3){const[D,G]=/:(\d+):/.exec(q.textContent.trim())||[],M=B[G];if(M)F.push((W)=>q.textContent=u(M(J)))}if(z==1){for(let W in b){const P=B[q.getAttribute(W)];if(W==":if"&&P&&q.getAttribute(":for"))if(P(J))continue;else q.removeAttribute(":for");if(P){q.removeAttribute(W);const L=b[W]({root:q,fn:P,fns:B,deps:R,ctx:J,processAttrs:I});return F.push(L.update),L}}const D=q.tagName.toLowerCase(),G=q.nextSibling;if(U&&D=="slot")return U.replace(q),{next:G};const M=R.find((W)=>W.name==D);if(M){if(q.firstChild){const L=document.createElement("_");L.append(...q.childNodes),M.inner=_({fns:B,dom:L},J,R)}const W=w(q),P=_(M,J,R,W).mount(q);if(K?.tagName.toLowerCase()==M.name)S.$el=P.$el;return F.push((L)=>H(P.$el,W)),S.$refs[q.getAttribute("ref")||D]=P.impl,{next:G}}else I(q),V(q,g)}}function I(q){for(let z of[...q.attributes])C(q,z.name,z.value)}function Z(q,z,D){if(q.getAttribute(z)!==D)q.setAttribute(z,D)}function C(q,z,D){if(z=="ref"||z=="name")S.$refs[D]=q;const G=B[D];if(!G)return;const M=z.slice(1),W=z[0];if(":@$".includes(W))q.removeAttribute(z);if(M=="attr")return F.push((P)=>{for(let[L,v]of Object.entries(G(J)))Z(q,L,v===!0?"":v)});if(W==":"){if(M!="bind")F.push((P)=>{let L=G(J);Z(q,M,u(L))})}else if(W=="@")q[`on${M}`]=(P)=>{G.call(J,J,P),(T?.update||E)()};else if(W=="$")F.push((P)=>{if(!(q[M]=!!G(J)))q.removeAttribute(M)});if(M=="html")F.push((P)=>q.innerHTML=G(J))}function V(q,z){let D=q.firstChild;while(D)D=z(D)?.next||D.nextSibling}function O(q,z){const D=q.getAttribute(":"+z),G=B[D];return G?G(J):J[D]||q.getAttribute(z)||q[z]||void 0}function A(q){const z={};for(let D of[...q.attributes]){const G=D.name.replace(":",""),M=O(q,G);if(!x.includes(G)&&typeof M!="object")z[G]=M==null?!0:M}return z}function w(q){return q.$attrs=A(q),new Proxy(q,{get(z,D){return O(q,D)}})}function H(q,z){const D=y(O(q,"class")||[],z.class);if(D[0])q.className=u(D," ");const{id:G,style:M}=z;if(M&&M.x!="")q.style=u(M);if(G)q.id=u(G)}function E(q){if(q)Object.assign(X,q);return F.map((z)=>z()),X.updated?.call(J,J),S}let X={};const S={update:E,$el:K,get root(){return S.$el},$refs:{},$parent:T,impl:X,mountChild(q,z,D){const G=R.find((M)=>M.name==q);if(G)_(G,D,R,J).mount(z)},mount(q){const z=K||(S.$el=f(N));let D=q.querySelector("script");if(D)Object.assign(Q,JSON.parse(D.textContent)),q.insertAdjacentElement("afterend",D);if(j)X=S.impl=new j(J),X.mountChild=S.mountChild,X.$refs=S.$refs,X.update=E;g(z),q.replaceWith(z);for(let G of[...q.attributes])Z(z,G.name,G.value);return X.mounted?.call(J,J),E()},append(q){const z=document.createElement("b");return q.append(z),S.mount(z)},replace(q){g(K),q.replaceWith(...K.children),E()},before(q){if(K){if(S.$el=K,!document.body.contains(K))q.before(K);if(!K.walked)g(K),K.walked=1;return E()}},unmount(){try{S.root.remove()}catch(q){}X.unmounted?.call(J,J),E()}},J=new Proxy({},{get(q,z){for(let D of[S,X,Q,T,T.bind]){const G=D&&D[z];if(G!=null)return G}},set(q,z,D){if(T&&T[z]!==void 0)T[z]=D,T.update();else S[z]=D;return!0}});return S}export{_ as default,_ as createApp};
